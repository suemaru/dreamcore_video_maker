<!--
ファイル構造:
your-project/
├── index.html (このファイル)
└── assets/
    └── bg_format.png (背景画像 - 2000x2000px、自動的に1000x1000pxにリサイズされます)

使用方法:
1. assetsフォルダを作成
2. bg_format.png（2000x2000px）を配置
3. ブラウザでindex.htmlを開く

注意: 背景画像は自動的に1000x1000pxにリサイズされ、
座標は1000px基準で計算されます。
-->
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DreamCore Video Maker</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="DreamCoreで作ったゲームの紹介動画を簡単生成！背景選択、色相調整、画像・動画アップロード機能付きの無料動画作成ツール" />
    <meta name="keywords" content="DreamCore,動画生成,ゲーム紹介,動画作成,無料ツール,React" />
    <meta name="author" content="@suemaruuuuuuX" />
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="DreamCore Video Maker - ゲーム紹介動画を簡単生成" />
    <meta property="og:description" content="DreamCoreで作ったゲームの紹介動画を簡単生成！背景選択、色相調整、画像・動画アップロード機能付きの無料動画作成ツール" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://dreamcore-video-maker.vercel.app/" />
    <meta property="og:image" content="https://dreamcore-video-maker.vercel.app/assets/twitter-image.png" />
    <meta property="og:site_name" content="DreamCore Video Maker" />
    <meta property="og:locale" content="ja_JP" />
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@suemaruuuuuuX" />
    <meta name="twitter:creator" content="@suemaruuuuuuX" />
    <meta name="twitter:title" content="DreamCore Video Maker - ゲーム紹介動画を簡単生成" />
    <meta name="twitter:description" content="DreamCoreで作ったゲームの紹介動画を簡単生成！背景選択、色相調整、画像・動画アップロード機能付きの無料動画作成ツール" />
    <meta name="twitter:image" content="https://dreamcore-video-maker.vercel.app/assets/twitter-image.png" />
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://dreamcore-video-maker.vercel.app/" />
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // アイコンコンポーネント（簡易版）
        const Upload = () => <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" /></svg>;
        const Download = () => <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>;
        const Play = () => <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.828 14.828a4 4 0 01-5.656 0M9 10h1.586a1 1 0 01.707.293l2.414 2.414a1 1 0 00.707.293H15" /></svg>;
        const Sparkles = () => <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 3a2 2 0 00-2 2v1c0 8.284 6.716 15 15 15h1a2 2 0 002-2V4a2 2 0 00-2-2H5z" /></svg>;
        const Gamepad2 = () => <svg className="w-16 h-16" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.828 14.828a4 4 0 01-5.656 0M9 10h1.586a1 1 0 01.707.293l2.414 2.414a1 1 0 00.707.293H15" /></svg>;
        const Video = () => <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>;
        const Link = () => <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" /></svg>;
        const Image = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg>;
        const Type = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 21h10v-2H7v2zM21 9h-8v6h8V9zM3 9h8v6H3V9z" /></svg>;
        const User = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" /></svg>;
        const XIcon = () => <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>;

        const DreamCoreVideoGenerator = () => {
            const [currentStep, setCurrentStep] = useState(0);
            const [gameData, setGameData] = useState(null);
            const [videoFile, setVideoFile] = useState(null);
            const [isProcessing, setIsProcessing] = useState(false);
            const [progress, setProgress] = useState(0);
            const [outputVideo, setOutputVideo] = useState(null);
            const [outputVideoMimeType, setOutputVideoMimeType] = useState(null);
            const [errorMessage, setErrorMessage] = useState('');
            const [manualData, setManualData] = useState({
                title: '',
                description: '',
                coverImage: null,
                accountImage: null
            });
            
            // 背景選択関連の状態
            const [selectedBackground, setSelectedBackground] = useState(1); // 1-6
            const [hueAdjustment, setHueAdjustment] = useState(0); // -180 to +180
            const [previewUrl, setPreviewUrl] = useState(null);
            const [backgroundImages, setBackgroundImages] = useState({}); // プリロードされた背景画像のキャッシュ
            const [isLoadingPreview, setIsLoadingPreview] = useState(false); // プレビュー生成中フラグ
            
            // モバイル対応関連の状態
            const [isMobile, setIsMobile] = useState(false);
            const [isEditAccordionOpen, setIsEditAccordionOpen] = useState(false);

            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const previewCanvasRef = useRef(null);
            const fileInputRef = useRef(null);
            const coverImageRef = useRef(null);
            const accountImageRef = useRef(null);

            // 色相調整済み背景画像をキャッシュ
            const [adjustedBackgroundCache, setAdjustedBackgroundCache] = useState({});

            // 背景または色相が変更された時に一度だけ重い処理
            const generateAdjustedBackground = async () => {
                const cacheKey = `${selectedBackground}-${hueAdjustment}`;
                
                if (adjustedBackgroundCache[cacheKey]) {
                    return adjustedBackgroundCache[cacheKey]; // キャッシュから取得
                }
                
                // 重い処理を一度だけ実行
                const adjustedImage = await processHueAdjustment();
                setAdjustedBackgroundCache(prev => ({
                    ...prev,
                    [cacheKey]: adjustedImage
                }));
                
                return adjustedImage;
            };

            // モバイル判定
            useEffect(() => {
                const checkMobile = () => {
                    setIsMobile(window.innerWidth < 1024); // lg breakpoint
                };
                
                checkMobile();
                window.addEventListener('resize', checkMobile);
                
                return () => window.removeEventListener('resize', checkMobile);
            }, []);

            // ステップ定義
            const steps = [
                { title: 'ゲーム情報', icon: Type },
                { title: '動画アップロード', icon: Video },
                { title: 'プレビュー', icon: Play },
                { title: '生成', icon: Download }
            ];

            // 色相調整スライダーコンポーネント（モバイル対応版）
            const HueSlider = ({ value, onChange }) => {
                const [isDragging, setIsDragging] = useState(false);

                // 共通の値更新処理
                const updateValue = (clientX, element) => {
                    const rect = element.getBoundingClientRect();
                    const x = clientX - rect.left;
                    const percentage = Math.max(0, Math.min(1, x / rect.width));
                    const hue = Math.round((percentage - 0.5) * 360); // -180 to +180
                    console.log('色相値更新:', hue, '度');
                    onChange(hue);
                };

                // マウスイベント
                const handleMouseMove = (e) => {
                    if (e.buttons !== 1) return; // 左クリック押下中のみ
                    updateValue(e.clientX, e.currentTarget);
                };

                const handleClick = (e) => {
                    updateValue(e.clientX, e.currentTarget);
                };

                // タッチイベント（モバイル対応）
                const handleTouchStart = (e) => {
                    e.preventDefault(); // デフォルトのスクロール等を防ぐ
                    setIsDragging(true);
                    updateValue(e.touches[0].clientX, e.currentTarget);
                };

                const handleTouchMove = (e) => {
                    if (!isDragging) return;
                    e.preventDefault(); // デフォルトのスクロール等を防ぐ
                    updateValue(e.touches[0].clientX, e.currentTarget);
                };

                const handleTouchEnd = (e) => {
                    e.preventDefault();
                    setIsDragging(false);
                };

                // value (-180 to +180) を percentage (0 to 1) に変換
                const valueToPercentage = (val) => (val + 180) / 360;

                return (
                    <div 
                        className="relative w-full h-8 cursor-pointer" 
                        onMouseMove={handleMouseMove} 
                        onClick={handleClick}
                        onTouchStart={handleTouchStart}
                        onTouchMove={handleTouchMove}
                        onTouchEnd={handleTouchEnd}
                        style={{ touchAction: 'none' }} // タッチ操作を最適化
                    >
                        {/* 色相バー */}
                        <div 
                            className="w-full h-full rounded-lg"
                            style={{
                                background: 'linear-gradient(to right, #00ffff, #0000ff, #ff00ff, #ff0000, #ffff00, #00ff00, #00ffff)'
                            }}
                        />
                        {/* スライダー */}
                        <div 
                            className="absolute top-0 w-0 h-0 pointer-events-none"
                            style={{
                                left: `${valueToPercentage(value) * 100}%`,
                                transform: 'translateX(-50%)',
                                borderLeft: '8px solid transparent',
                                borderRight: '8px solid transparent',
                                borderTop: '12px solid white',
                                filter: 'drop-shadow(0 2px 4px rgba(0,0,0,0.3))'
                            }}
                        />
                        <div 
                            className="absolute bottom-0 w-0 h-0 pointer-events-none"
                            style={{
                                left: `${valueToPercentage(value) * 100}%`,
                                transform: 'translateX(-50%)',
                                borderLeft: '8px solid transparent',
                                borderRight: '8px solid transparent',
                                borderBottom: '12px solid white',
                                filter: 'drop-shadow(0 2px 4px rgba(0,0,0,0.3))'
                            }}
                        />
                    </div>
                );
            };

            // 背景画像プリロード関数
            const preloadBackgroundImages = async () => {
                console.log('背景画像のプリロードを開始...');
                const promises = [];
                
                for (let i = 1; i <= 6; i++) {
                    if (!backgroundImages[i]) { // まだキャッシュされていない場合のみ
                        promises.push(
                            new Promise((resolve) => {
                                const img = document.createElement('img');
                                img.addEventListener('load', () => {
                                    console.log(`背景画像 ${i} の読み込み完了`);
                                    resolve({ index: i, image: img });
                                });
                                img.addEventListener('error', () => {
                                    console.log(`背景画像 ${i} の読み込み失敗、デフォルト画像を生成`);
                                    // デフォルト背景を作成
                                    const canvas = document.createElement('canvas');
                                    canvas.width = 1000;
                                    canvas.height = 1000;
                                    const ctx = canvas.getContext('2d');
                                    ctx.fillStyle = '#FF6B35';
                                    ctx.fillRect(0, 0, 1000, 1000);
                                    
                                    const defaultImg = document.createElement('img');
                                    defaultImg.addEventListener('load', () => {
                                        resolve({ index: i, image: defaultImg });
                                    });
                                    defaultImg.src = canvas.toDataURL();
                                });
                                img.src = `./assets/bg_format_${i}.png`;
                            })
                        );
                    }
                }
                
                // 全ての背景画像を並行して読み込み
                const loadedImages = await Promise.all(promises);
                
                // キャッシュに保存
                const newBackgroundImages = { ...backgroundImages };
                loadedImages.forEach(({ index, image }) => {
                    newBackgroundImages[index] = image;
                });
                setBackgroundImages(newBackgroundImages);
                
                console.log('全ての背景画像のプリロードが完了');
                return newBackgroundImages;
            };

            // 色相調整を手動で適用する関数（Canvas filterの代替・最適化版）
            const applyHueRotationToCanvas = (ctx, imageData, hue) => {
                if (hue === 0 || !imageData) return imageData;
                
                try {
                    const data = new Uint8ClampedArray(imageData.data);
                    const hueRotation = (hue / 360) % 1; // 正規化された色相回転
                    
                    // 最適化されたRGB to HSL および HSL to RGB 変換関数
                    const rgbToHsl = (r, g, b) => {
                        r /= 255; g /= 255; b /= 255;
                        const max = Math.max(r, g, b);
                        const min = Math.min(r, g, b);
                        let h, s, l = (max + min) / 2;
                        
                        if (max === min) {
                            h = s = 0; // グレースケール
                        } else {
                            const d = max - min;
                            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                            switch (max) {
                                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                                case g: h = (b - r) / d + 2; break;
                                case b: h = (r - g) / d + 4; break;
                            }
                            h /= 6;
                        }
                        return [h, s, l];
                    };
                    
                    const hslToRgb = (h, s, l) => {
                        let r, g, b;
                        
                        if (s === 0) {
                            r = g = b = l; // グレースケール
                        } else {
                            const hue2rgb = (p, q, t) => {
                                if (t < 0) t += 1;
                                if (t > 1) t -= 1;
                                if (t < 1/6) return p + (q - p) * 6 * t;
                                if (t < 1/2) return q;
                                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                                return p;
                            };
                            
                            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                            const p = 2 * l - q;
                            r = hue2rgb(p, q, h + 1/3);
                            g = hue2rgb(p, q, h);
                            b = hue2rgb(p, q, h - 1/3);
                        }
                        
                        return [r * 255, g * 255, b * 255];
                    };
                    
                    // ピクセル処理（4つずつ処理してバッチ最適化）
                    const len = data.length;
                    for (let i = 0; i < len; i += 4) {
                        const a = data[i + 3];
                        
                        // 透明度が低いピクセルはスキップ
                        if (a < 5) continue;
                        
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        
                        // グレーピクセルの場合は処理をスキップ（最適化）
                        if (Math.abs(r - g) < 2 && Math.abs(g - b) < 2 && Math.abs(r - b) < 2) {
                            continue;
                        }
                        
                        // RGB to HSL
                        const [h, s, l] = rgbToHsl(r, g, b);
                        
                        // 色相を回転（正規化）
                        let newH = h + hueRotation;
                        if (newH < 0) newH += 1;
                        if (newH > 1) newH -= 1;
                        
                        // HSL to RGB
                        const [newR, newG, newB] = hslToRgb(newH, s, l);
                        
                        // 値をクランプしてから設定
                        data[i] = Math.max(0, Math.min(255, Math.round(newR)));
                        data[i + 1] = Math.max(0, Math.min(255, Math.round(newG)));
                        data[i + 2] = Math.max(0, Math.min(255, Math.round(newB)));
                        // アルファ値は変更しない
                    }
                    
                    return new ImageData(data, imageData.width, imageData.height);
                } catch (error) {
                    console.error('色相調整エラー:', error);
                    // エラーが発生した場合は元の画像データを返す
                    return imageData;
                }
            };

            // Canvas filter対応の判定
            const checkCanvasFilterSupport = () => {
                try {
                    const testCanvas = document.createElement('canvas');
                    const testCtx = testCanvas.getContext('2d');
                    testCtx.filter = 'hue-rotate(10deg)';
                    return testCtx.filter === 'hue-rotate(10deg)';
                } catch (error) {
                    return false;
                }
            };

            const canvasFilterSupported = checkCanvasFilterSupport();
            console.log('Canvas filter サポート状況:', canvasFilterSupported ? 'サポート済み' : '非サポート（手動実装を使用）');
            console.log('User Agent:', navigator.userAgent);

            // プレビュー生成関数（モバイル対応版・自動フォールバック）
            const generatePreview = async (bgIndex = selectedBackground, hue = hueAdjustment, data = gameData) => {
                if (!data) return;

                const canvas = previewCanvasRef.current;
                if (!canvas) return;

                setIsLoadingPreview(true);

                const ctx = canvas.getContext('2d');
                canvas.width = 400; // プレビュー用の小さいサイズ
                canvas.height = 400;

                try {
                    // キャッシュされた背景画像を使用（高速化）
                    let backgroundImg = backgroundImages[bgIndex];
                    
                    if (!backgroundImg) {
                        console.log(`背景画像 ${bgIndex} がキャッシュにない、個別に読み込み中...`);
                        // キャッシュにない場合は個別に読み込み
                        backgroundImg = await new Promise((resolve, reject) => {
                            const img = document.createElement('img');
                            
                            img.addEventListener('load', () => {
                                // 読み込んだ画像をキャッシュに保存
                                setBackgroundImages(prev => ({ ...prev, [bgIndex]: img }));
                                resolve(img);
                            });
                            img.addEventListener('error', () => {
                                // デフォルト背景を作成
                                const canvas = document.createElement('canvas');
                                canvas.width = 400;
                                canvas.height = 400;
                                const ctx = canvas.getContext('2d');
                                ctx.fillStyle = '#FF6B35';
                                ctx.fillRect(0, 0, 400, 400);
                                
                                const defaultImg = document.createElement('img');
                                defaultImg.addEventListener('load', () => resolve(defaultImg));
                                defaultImg.src = canvas.toDataURL();
                            });
                            
                            img.src = `./assets/bg_format_${bgIndex}.png`;
                        });
                    }

                    // 色相調整の適用（パフォーマンス優先版）
                    if (hue !== 0 && canvasFilterSupported) {
                        // Canvas filterを使用（高速）
                        console.log('Canvas filter使用:', hue, '度');
                        ctx.filter = `hue-rotate(${hue}deg)`;
                        ctx.drawImage(backgroundImg, 0, 0, 400, 400);
                        ctx.filter = 'none'; // フィルターをリセット
                        console.log('Canvas filter色相調整完了');
                    } else if (hue !== 0) {
                        // 手動実装をフォールバックとして使用
                        console.log('手動色相調整適用中:', hue, '度');
                        ctx.drawImage(backgroundImg, 0, 0, 400, 400);
                        const imageData = ctx.getImageData(0, 0, 400, 400);
                        const adjustedImageData = applyHueRotationToCanvas(ctx, imageData, hue);
                        if (adjustedImageData) {
                            ctx.putImageData(adjustedImageData, 0, 0);
                            console.log('手動色相調整完了');
                        } else {
                            console.log('色相調整失敗、元の画像を使用');
                        }
                    } else {
                        // 色相調整なしで描画
                        ctx.drawImage(backgroundImg, 0, 0, 400, 400);
                    }

                    // 画像の読み込み（FileReaderを使用）
                    const loadImageFromFile = (file) => {
                        return new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.addEventListener('load', (e) => {
                                const img = document.createElement('img');
                                img.addEventListener('load', () => resolve(img));
                                img.addEventListener('error', reject);
                                img.src = e.target.result;
                            });
                            reader.addEventListener('error', reject);
                            reader.readAsDataURL(file);
                        });
                    };

                    // アカウント画像の描画（円形）
                    if (data.accountImage) {
                        try {
                            const accountImg = data.accountImage instanceof File ? 
                                await loadImageFromFile(data.accountImage) : 
                                await new Promise((resolve, reject) => {
                                    const img = document.createElement('img');
                                    img.addEventListener('load', () => resolve(img));
                                    img.addEventListener('error', reject);
                                    img.src = data.accountImage;
                                });

                            const accountX = 150; // 400pxキャンバスでの位置調整
                            const accountY = 80;
                            const accountRadius = 28; // 小さいサイズ

                            // 外側のボーダー（白）
                            ctx.save();
                            ctx.beginPath();
                            ctx.arc(accountX, accountY, accountRadius + 1, 0, 2 * Math.PI);
                            ctx.fillStyle = '#ffffff';
                            ctx.fill();
                            
                            // 画像を円形にクリップして描画
                            ctx.beginPath();
                            ctx.arc(accountX, accountY, accountRadius, 0, 2 * Math.PI);
                            ctx.clip();
                            ctx.drawImage(accountImg, accountX - accountRadius, accountY - accountRadius, 
                                        accountRadius * 2, accountRadius * 2);
                            ctx.restore();
                        } catch (e) {
                            console.log('アカウント画像の描画に失敗:', e);
                        }
                    }

                    // カバー画像の描画
                    if (data.coverImage) {
                        try {
                            const coverImg = data.coverImage instanceof File ? 
                                await loadImageFromFile(data.coverImage) : 
                                await new Promise((resolve, reject) => {
                                    const img = document.createElement('img');
                                    img.addEventListener('load', () => resolve(img));
                                    img.addEventListener('error', reject);
                                    img.src = data.coverImage;
                                });

                            const targetHeight = 194; // 400pxキャンバスでの位置調整
                            const aspectRatio = coverImg.width / coverImg.height;
                            const targetWidth = targetHeight * aspectRatio;
                            
                            const coverX = 96 - (targetWidth / 2);
                            const coverY = 123;
                            
                            // 外側のボーダー（白）
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(coverX - 1, coverY - 1, targetWidth + 2, targetHeight + 2);
                            
                            // 画像を描画
                            ctx.drawImage(coverImg, coverX, coverY, targetWidth, targetHeight);
                        } catch (e) {
                            console.log('カバー画像の描画に失敗:', e);
                        }
                    }

                    // テキストの描画
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 13px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(data.title, 96, 337);

                    // 説明文の描画
                    ctx.font = '9px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    const descY = 351;
                    
                    // 改行処理
                    const maxWidth = 160;
                    const lineHeight = 10;
                    const lines = [];
                    let line = '';
                    
                    for (let i = 0; i < data.description.length; i++) {
                        const char = data.description[i];
                        const testLine = line + char;
                        const metrics = ctx.measureText(testLine);
                        const testWidth = metrics.width;
                        
                        if (testWidth > maxWidth && line.length > 0) {
                            lines.push(line);
                            line = char;
                        } else {
                            line = testLine;
                        }
                    }
                    if (line.length > 0) {
                        lines.push(line);
                    }
                    
                    lines.forEach((line, index) => {
                        ctx.fillText(line.trim(), 96, descY + (index * lineHeight));
                    });

                    // プレビューURLを生成
                    const previewDataUrl = canvas.toDataURL();
                    setPreviewUrl(previewDataUrl);

                } catch (error) {
                    console.error('プレビュー生成エラー:', error);
                } finally {
                    setIsLoadingPreview(false);
                }
            };

            // プレビューステップに入った時に背景画像をプリロード
            useEffect(() => {
                if (currentStep === 2 && gameData) {
                    preloadBackgroundImages().then(() => {
                        generatePreview();
                    });
                }
            }, [currentStep, gameData]);

            // 背景やhueが変更されたときにプレビューを更新
            useEffect(() => {
                if (currentStep === 2 && gameData && Object.keys(backgroundImages).length > 0) {
                    console.log('プレビュー更新: 背景=', selectedBackground, ', 色相=', hueAdjustment);
                    generatePreview();
                }
            }, [selectedBackground, hueAdjustment]);



            // 手動データの送信
            const handleManualDataSubmit = () => {
                if (!manualData.title || !manualData.description) {
                    alert('タイトルと説明文は必須です');
                    return;
                }
                setGameData(manualData);
                setCurrentStep(1);
            };

            // 動画ファイルの処理
            const handleVideoUpload = (event) => {
                const file = event.target.files[0];
                if (file && file.type.startsWith('video/')) {
                    setVideoFile(file);
                    setCurrentStep(2);
                } else {
                    alert('動画ファイルを選択してください');
                }
            };

            // 画像ファイルの処理（改善版）
            const handleImageUpload = (event, type) => {
                const file = event.target.files[0];
                if (file) {
                    // サポートされている形式をチェック
                    const supportedTypes = ['image/png', 'image/jpeg', 'image/jpg', 'image/gif'];
                    if (!supportedTypes.includes(file.type)) {
                        alert('PNG, JPEG, GIF形式の画像をアップロードしてください。WebP形式はサポートされていません。');
                        event.target.value = ''; // ファイル選択をリセット
                        return;
                    }
                    
                    if (file.type.startsWith('image/')) {
                        // blob URLではなく、ファイル自体を保存
                        setManualData(prev => ({
                            ...prev,
                            [type]: file  // fileオブジェクト自体を保存
                        }));
                        console.log(`${type}アップロード成功:`, file.type, file.size);
                    } else {
                        alert('画像ファイルを選択してください');
                    }
                }
            };

            // 動画生成処理
            const generateVideo = async () => {
                if (!videoFile || !gameData) return;

                setIsProcessing(true);
                setProgress(0);
                setCurrentStep(3);
                setErrorMessage('');

                try {
                    // プログレスバーのアニメーション
                    const progressAnimation = async () => {
                        for (let i = 0; i <= 90; i += 10) {
                            setProgress(i);
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    };
                    progressAnimation();

                    // Canvas での動画合成処理
                    const canvas = canvasRef.current;
                    const ctx = canvas.getContext('2d');
                    canvas.width = 1000;  // 1000x1000に変更
                    canvas.height = 1000;

                    // キャッシュされた背景画像を使用（動画生成も高速化）
                    let backgroundImg = backgroundImages[selectedBackground];
                    
                    if (!backgroundImg) {
                        console.log(`動画生成用背景画像 ${selectedBackground} をキャッシュから取得できません、個別に読み込み中...`);
                        // キャッシュにない場合は個別に読み込み
                        backgroundImg = await new Promise((resolve, reject) => {
                            const img = document.createElement('img');
                            
                            img.addEventListener('load', () => resolve(img));
                            img.addEventListener('error', () => {
                                console.log('背景画像が見つかりません。デフォルト背景を使用します。');
                                // デフォルト背景を作成
                                const canvas = document.createElement('canvas');
                                canvas.width = 1000;  // 1000x1000に変更
                                canvas.height = 1000;
                                const ctx = canvas.getContext('2d');
                                ctx.fillStyle = '#FF6B35';
                                ctx.fillRect(0, 0, 1000, 1000);
                                
                                // DreamCoreロゴエリア（左上）
                                ctx.fillStyle = '#FFFFFF';
                                ctx.font = 'bold 30px Arial';  // サイズ調整（60/2）
                                ctx.fillText('DreamCore', 55, 92);  // 座標調整（111/2, 185/2）
                                ctx.fillText('×', 222, 92);  // 座標調整（444/2, 185/2）
                                
                                // ピンク枠の描画（左側）
                                ctx.fillStyle = '#FF1493';
                                ctx.fillRect(111, 312, 370, 520);  // 座標・サイズ調整（全て半分）
                                
                                // 青枠の描画（右側）
                                ctx.fillStyle = '#1E90FF';
                                ctx.fillRect(532, 129, 463, 740);  // 座標・サイズ調整（全て半分）
                                
                                const defaultImg = document.createElement('img');
                                defaultImg.addEventListener('load', () => resolve(defaultImg));
                                defaultImg.src = canvas.toDataURL();
                            });
                            
                            // CORS問題を回避するため、同一オリジンでのみ読み込み
                            img.src = `./assets/bg_format_${selectedBackground}.png`;
                        });
                    }

                    // ユーザーがアップロードした動画を読み込み
                    const videoElement = document.createElement('video');
                    videoElement.src = URL.createObjectURL(videoFile);
                    videoElement.muted = true;
                    videoElement.loop = true;
                    videoElement.playsInline = true; // iOSでの自動再生対応
                    videoElement.preload = 'metadata'; // メタデータのみ読み込み

                    // 動画の読み込み完了を待機
                    await new Promise((resolve, reject) => {
                        videoElement.onloadedmetadata = resolve;
                        videoElement.onerror = reject;
                        setTimeout(reject, 10000); // 10秒でタイムアウト
                    });

                    // 画像の読み込み（CORS問題対応）
                    const loadImage = (src) => {
                        return new Promise((resolve, reject) => {
                            const img = document.createElement('img');
                            
                            img.addEventListener('load', () => resolve(img));
                            img.addEventListener('error', () => {
                                console.log('画像読み込み失敗、デフォルト画像を作成:', src);
                                // デフォルト画像を作成
                                const canvas = document.createElement('canvas');
                                canvas.width = 400;
                                canvas.height = 400;
                                const ctx = canvas.getContext('2d');
                                ctx.fillStyle = '#ddd';
                                ctx.fillRect(0, 0, 400, 400);
                                ctx.fillStyle = '#999';
                                ctx.font = '20px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillText('画像', 200, 200);
                                
                                const defaultImg = document.createElement('img');
                                defaultImg.addEventListener('load', () => resolve(defaultImg));
                                defaultImg.src = canvas.toDataURL();
                            });
                            
                            // ローカルファイルの場合はcrossOriginを設定しない
                            if (!src.startsWith('http')) {
                                img.src = src;
                            } else {
                                // 外部URLの場合のみcrossOriginを設定（ただし失敗する可能性が高い）
                                try {
                                    img.crossOrigin = 'anonymous';
                                    img.src = src;
                                } catch (e) {
                                    console.log('crossOrigin設定失敗、代替画像を使用');
                                    // 代替として空の画像を作成
                                    const canvas = document.createElement('canvas');
                                    canvas.width = 400;
                                    canvas.height = 400;
                                    const ctx = canvas.getContext('2d');
                                    ctx.fillStyle = '#f0f0f0';
                                    ctx.fillRect(0, 0, 400, 400);
                                    
                                    const fallbackImg = document.createElement('img');
                                    fallbackImg.addEventListener('load', () => resolve(fallbackImg));
                                    fallbackImg.src = canvas.toDataURL();
                                }
                            }
                        });
                    };

                    // FileReader を使用して画像ファイルを読み込み
                    const loadImageFromFile = (file) => {
                        return new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.addEventListener('load', (e) => {
                                const img = document.createElement('img');
                                img.addEventListener('load', () => resolve(img));
                                img.addEventListener('error', reject);
                                img.src = e.target.result;
                            });
                            reader.addEventListener('error', reject);
                            reader.readAsDataURL(file);
                        });
                    };

                    let coverImg = null;
                    let accountImg = null;

                    // カバー画像の読み込み処理
                    if (gameData.coverImage) {
                        try {
                            if (gameData.coverImage instanceof File) {
                                // アップロードされたファイルの場合
                                console.log('カバー画像をFileReaderで読み込み中...');
                                coverImg = await loadImageFromFile(gameData.coverImage);
                                console.log('カバー画像読み込み成功');
                            } else if (typeof gameData.coverImage === 'string') {
                                // 外部URLまたはデモ画像の場合
                                console.log('カバー画像をURLから読み込み中:', gameData.coverImage);
                                coverImg = await loadImage(gameData.coverImage);
                                console.log('カバー画像読み込み成功');
                            }
                        } catch (e) {
                            console.log('カバー画像の読み込みに失敗:', e);
                        }
                    } else {
                        console.log('カバー画像が設定されていません');
                    }

                    // アカウント画像の読み込み処理
                    if (gameData.accountImage) {
                        try {
                            if (gameData.accountImage instanceof File) {
                                // アップロードされたファイルの場合
                                console.log('アカウント画像をFileReaderで読み込み中...');
                                accountImg = await loadImageFromFile(gameData.accountImage);
                                console.log('アカウント画像読み込み成功');
                            } else if (typeof gameData.accountImage === 'string') {
                                // 外部URLまたはデモ画像の場合
                                console.log('アカウント画像をURLから読み込み中:', gameData.accountImage);
                                accountImg = await loadImage(gameData.accountImage);
                                console.log('アカウント画像読み込み成功');
                            }
                        } catch (e) {
                            console.log('アカウント画像の読み込みに失敗:', e);
                        }
                    } else {
                        console.log('アカウント画像が設定されていません');
                    }

                    // 動画の描画関数
                    const drawFrame = () => {
                        // 背景画像のサイズをログ出力（デバッグ用）
                        console.log('描画時の背景画像サイズ:', backgroundImg.width, 'x', backgroundImg.height);
                        
                        // 色相調整の適用（パフォーマンス優先版）
                        if (hueAdjustment !== 0 && canvasFilterSupported) {
                            // Canvas filterを使用（高速）
                            console.log('動画生成: Canvas filter使用:', hueAdjustment, '度');
                            ctx.filter = `hue-rotate(${hueAdjustment}deg)`;
                            ctx.drawImage(backgroundImg, 0, 0, 1000, 1000);
                            ctx.filter = 'none'; // フィルターをリセット
                            console.log('動画生成: Canvas filter色相調整完了');
                        } else if (hueAdjustment !== 0) {
                            // 手動実装をフォールバックとして使用
                            console.log('動画生成: 手動色相調整適用中:', hueAdjustment, '度');
                            ctx.drawImage(backgroundImg, 0, 0, 1000, 1000);
                            const imageData = ctx.getImageData(0, 0, 1000, 1000);
                            const adjustedImageData = applyHueRotationToCanvas(ctx, imageData, hueAdjustment);
                            if (adjustedImageData) {
                                ctx.putImageData(adjustedImageData, 0, 0);
                                console.log('動画生成: 手動色相調整完了');
                            } else {
                                console.log('動画生成: 色相調整失敗、元の画像を使用');
                            }
                        } else {
                            // 色相調整なしで描画
                            ctx.drawImage(backgroundImg, 0, 0, 1000, 1000);
                        }

                        // アカウント画像の描画（円形、x:376 y:200中心、直径140px）
                        if (accountImg) {
                            console.log('アカウント画像を描画中...');
                            const accountX = 376;   // 中心X座標（753/2）
                            const accountY = 200;   // 中心Y座標（400/2）
                            const accountRadius = 70; // 半径（直径140px）
                            
                            // 外側のボーダー（白、2px）
                            ctx.save();
                            ctx.beginPath();
                            ctx.arc(accountX, accountY, accountRadius + 2, 0, 2 * Math.PI);
                            ctx.fillStyle = '#ffffff';
                            ctx.fill();
                            
                            // 画像を円形にクリップして描画
                            ctx.beginPath();
                            ctx.arc(accountX, accountY, accountRadius, 0, 2 * Math.PI);
                            ctx.clip();
                            ctx.drawImage(accountImg, accountX - accountRadius, accountY - accountRadius, 
                                        accountRadius * 2, accountRadius * 2);
                            ctx.restore();
                        } else {
                            console.log('アカウント画像がありません');
                            // デバッグ用の円を描画
                            ctx.strokeStyle = '#FF0000';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(376, 200, 70, 0, 2 * Math.PI);
                            ctx.stroke();
                        }

                        // カバー画像の描画（x:241 y:308が上端中心、高さ485px、縦横比保持）
                        if (coverImg) {
                            console.log('カバー画像を描画中...');
                            const targetHeight = 485;  // 970/2
                            const aspectRatio = coverImg.width / coverImg.height;
                            const targetWidth = targetHeight * aspectRatio;
                            
                            const coverX = 241 - (targetWidth / 2); // 中心から左端を計算（483/2）
                            const coverY = 308; // 上端（617/2）
                            
                            // 外側のボーダー（白、2px）
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(coverX - 2, coverY - 2, targetWidth + 4, targetHeight + 4);
                            
                            // 画像を描画
                            ctx.drawImage(coverImg, coverX, coverY, targetWidth, targetHeight);
                        } else {
                            console.log('カバー画像がありません');
                            // デバッグ用の矩形を描画
                            ctx.strokeStyle = '#FF0000';
                            ctx.lineWidth = 3;
                            ctx.strokeRect(241 - 100, 308, 200, 485);
                        }

                        // ユーザーの動画を描画（x:700 y:500中心、幅400px、縦横比保持）
                        if (videoElement.readyState >= 2) {
                            try {
                                // 動画のサイズが有効かチェック
                                if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {
                                    const targetWidth = 400;  // 800/2
                                    const aspectRatio = videoElement.videoHeight / videoElement.videoWidth;
                                    const targetHeight = targetWidth * aspectRatio;
                                    
                                    const videoX = 700 - (targetWidth / 2); // 中心から左端を計算（1400/2）
                                    const videoY = 500 - (targetHeight / 2); // 中心から上端を計算（1000/2）
                                    
                                    // 動画を描画（ボーダーなし）
                                    ctx.drawImage(videoElement, videoX, videoY, targetWidth, targetHeight);
                                } else {
                                    console.log('動画サイズが無効:', videoElement.videoWidth, 'x', videoElement.videoHeight);
                                    // プレースホルダーを描画
                                    ctx.fillStyle = '#333333';
                                    ctx.fillRect(700 - 200, 500 - 150, 400, 300);
                                    ctx.fillStyle = '#FFFFFF';
                                    ctx.font = '20px Arial';
                                    ctx.textAlign = 'center';
                                    ctx.fillText('動画読み込み中...', 700, 500);
                                }
                            } catch (e) {
                                console.log('動画描画エラー:', e);
                                // プレースホルダーを描画
                                ctx.fillStyle = '#333333';
                                ctx.fillRect(700 - 200, 500 - 150, 400, 300);
                                ctx.fillStyle = '#FFFFFF';
                                ctx.font = '20px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillText('動画描画エラー', 700, 500);
                            }
                        } else {
                            // 動画がまだ準備できていない場合のプレースホルダー
                            ctx.fillStyle = '#333333';
                            ctx.fillRect(700 - 200, 500 - 150, 400, 300);
                            ctx.fillStyle = '#FFFFFF';
                            ctx.font = '20px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('動画準備中...', 700, 500);
                        }

                        // ゲームタイトルの描画（x:241 y:843中心、中央揃え）
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = 'bold 33px Arial';  // 66/2
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const titleX = 241;  // 483/2
                        const titleY = 843;  // 1686/2
                        ctx.fillText(gameData.title, titleX, titleY);

                        // 説明文の描画（x:241 y:879を1行目中心、中央揃え、改行対応）
                        ctx.font = '22px Arial';  // 44/2
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'top';
                        const descX = 241;  // 483/2
                        let descY = 879 - 11; // フォントサイズの半分を引いて中心調整（1759/2）
                        
                        // 改行処理（日本語対応）
                        const maxWidth = 400; // 最大幅（1500/2）
                        const lineHeight = 25; // 行間（55/2）
                        const lines = [];
                        let line = '';
                        
                        // 日本語・英語両対応の改行処理
                        for (let i = 0; i < gameData.description.length; i++) {
                            const char = gameData.description[i];
                            const testLine = line + char;
                            const metrics = ctx.measureText(testLine);
                            const testWidth = metrics.width;
                            
                            if (testWidth > maxWidth && line.length > 0) {
                                // 改行位置の調整（句読点の後で改行するとより自然）
                                lines.push(line);
                                line = char;
                            } else {
                                line = testLine;
                            }
                        }
                        if (line.length > 0) {
                            lines.push(line);
                        }
                        
                        // 各行を描画
                        lines.forEach((line, index) => {
                            ctx.fillText(line.trim(), descX, descY + (index * lineHeight));
                        });
                    };

                    // 初期フレームを描画
                    drawFrame();
                    console.log('初期フレーム描画完了');

                    // Canvas の origin-clean 状態をチェック
                    try {
                        // テスト用に小さなImageDataを取得してみる
                        const testData = ctx.getImageData(0, 0, 1, 1);
                        console.log('Canvas は origin-clean です');
                        console.log('Canvas サイズ:', canvas.width, 'x', canvas.height);
                    } catch (securityError) {
                        console.error('Canvas が origin-clean ではありません:', securityError);
                        throw new Error('画像のセキュリティ制限により動画生成ができません。ローカルHTTPサーバーを使用してください。');
                    }

                    // MediaRecorder で動画として出力（解像度を明示的に指定）
                    const canvasStream = canvas.captureStream(30);
                    console.log('Canvas stream 取得成功');
                    
                    // ストリームの解像度を確認
                    const videoTrack = canvasStream.getVideoTracks()[0];
                    const settings = videoTrack.getSettings();
                    console.log('Stream 解像度:', settings.width, 'x', settings.height);
                    
                    // 音声ストリームを取得（アップロード動画から）
                    let finalStream = canvasStream;
                    let tempVideo = null; // 音声用の動画要素
                    
                    try {
                        // 動画ファイルのストリームを作成
                        tempVideo = document.createElement('video');
                        tempVideo.src = URL.createObjectURL(videoFile);
                        tempVideo.muted = false; // モバイルでの音声取得のためミュートを解除
                        tempVideo.loop = true; // ループ再生で同期を保つ
                        tempVideo.playsInline = true; // iOSでの自動再生対応
                        tempVideo.preload = 'auto'; // 完全に読み込み（音声トラック取得のため）
                        tempVideo.volume = 0; // 音量を0に設定（音声トラック取得のため）
                        
                        // DOM に一時的に追加（モバイルでの再生制限回避）
                        tempVideo.style.position = 'absolute';
                        tempVideo.style.top = '-9999px';
                        tempVideo.style.left = '-9999px';
                        tempVideo.style.width = '1px';
                        tempVideo.style.height = '1px';
                        document.body.appendChild(tempVideo);
                        
                        // 動画が読み込まれるまで待機
                        await new Promise((resolve, reject) => {
                            tempVideo.onloadedmetadata = resolve;
                            tempVideo.onerror = reject;
                            setTimeout(reject, 5000); // 5秒でタイムアウト
                        });
                        
                        // MediaStreamを作成して音声トラックを取得（モバイル対応強化版）
                        console.log('captureStream サポート:', !!tempVideo.captureStream);
                        
                        if (tempVideo.captureStream) {
                            // モバイルでの再生確保：先に動画を再生開始
                            tempVideo.currentTime = 0;
                            tempVideo.volume = 0; // 音量を0に設定（音は出さないが音声トラックは取得）
                            
                            try {
                                // ユーザーインタラクションを活用した再生試行
                                console.log('音声用動画再生開始を試行中...');
                                const audioPlayPromise = tempVideo.play();
                                if (audioPlayPromise !== undefined) {
                                    await Promise.race([
                                        audioPlayPromise,
                                        new Promise((_, reject) => setTimeout(() => reject(new Error('音声再生タイムアウト')), 5000))
                                    ]);
                                }
                                console.log('音声用動画再生開始成功（音量0）');
                                
                                // 少し待ってからcaptureStreamを実行（モバイル対応）
                                await new Promise(resolve => setTimeout(resolve, 100));
                                
                                // 再生開始後にcaptureStreamを実行
                                const videoMediaStream = tempVideo.captureStream();
                                console.log('captureStream実行完了');
                                
                                const audioTracks = videoMediaStream.getAudioTracks();
                                console.log('取得した音声トラック数:', audioTracks.length);
                                
                                if (audioTracks.length > 0) {
                                    console.log('音声トラック検出:', audioTracks.length + '個');
                                    
                                    // 音声トラックの詳細情報をログ出力
                                    audioTracks.forEach((track, index) => {
                                        console.log(`音声トラック${index}:`, {
                                            enabled: track.enabled,
                                            readyState: track.readyState,
                                            kind: track.kind,
                                            label: track.label
                                        });
                                    });
                                    
                                    // 新しいMediaStreamを作成して音声とビデオを合成
                                    const combinedStream = new MediaStream();
                                    
                                    // ビデオトラックを追加
                                    canvasStream.getVideoTracks().forEach(track => {
                                        combinedStream.addTrack(track);
                                    });
                                    
                                    // 音声トラックを追加
                                    audioTracks.forEach(track => {
                                        combinedStream.addTrack(track);
                                    });
                                    
                                    finalStream = combinedStream;
                                    console.log('音声付きストリーム作成成功');
                                    console.log('最終ストリームのトラック数:', finalStream.getTracks().length);
                                } else {
                                    console.log('音声トラックが見つかりません');
                                }
                            } catch (audioPlayError) {
                                console.log('音声用動画の再生に失敗:', audioPlayError);
                                console.log('音声なしで動画生成を続行');
                            }
                        } else {
                            console.log('captureStream()がサポートされていません');
                        }
                        
                    } catch (audioError) {
                        console.log('音声トラック取得に失敗、ビデオのみで録画:', audioError);
                        // 音声なしでも録画は続行
                    }
                    
                    // ブラウザ対応の確認（モバイル対応版）
                    let mimeType = '';
                    let videoBitsPerSecond = 8000000; // デフォルト 8Mbps
                    
                    if (typeof MediaRecorder === 'undefined') {
                        throw new Error('このブラウザは動画録画をサポートしていません');
                    }
                    
                    // モバイル環境では低ビットレートに調整
                    if (isMobileDevice) {
                        videoBitsPerSecond = 4000000; // 4Mbps（モバイル用）
                        console.log('モバイル環境: ビットレートを4Mbpsに調整');
                    }
                    
                    // サポートされているMIMEタイプを順次チェック
                    const mimeTypes = [
                        'video/mp4',
                        'video/mp4;codecs=avc1.42E01E,mp4a.40.2',
                        'video/webm;codecs=vp9,opus',
                        'video/webm;codecs=vp8,opus',
                        'video/webm;codecs=vp9',
                        'video/webm;codecs=vp8',
                        'video/webm'
                    ];
                    
                    for (const type of mimeTypes) {
                        if (MediaRecorder.isTypeSupported(type)) {
                            mimeType = type;
                            break;
                        }
                    }
                    
                    if (!mimeType) {
                        throw new Error('このブラウザは対応可能な動画形式がありません');
                    }
                    
                    console.log('使用するMIMEタイプ:', mimeType);
                    console.log('ビットレート:', videoBitsPerSecond);

                    // MediaRecorderの設定（モバイル対応版）
                    const recorderOptions = { 
                        mimeType,
                        videoBitsPerSecond
                    };
                    
                    // モバイルでは音声ビットレートも調整
                    if (isMobileDevice && finalStream.getAudioTracks().length > 0) {
                        recorderOptions.audioBitsPerSecond = 128000; // 128kbps
                    }
                    
                    const mediaRecorder = new MediaRecorder(finalStream, recorderOptions);
                    
                    const chunks = [];
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            chunks.push(event.data);
                        }
                    };

                    mediaRecorder.onstop = () => {
                        try {
                            const blob = new Blob(chunks, { type: mimeType });
                            const url = URL.createObjectURL(blob);
                            console.log('動画生成完了 - Blob サイズ:', blob.size, 'bytes');
                            console.log('MIMEタイプ:', blob.type);
                            setOutputVideo(url);
                            setOutputVideoMimeType(mimeType);
                            setProgress(100);
                            setIsProcessing(false);
                        } catch (e) {
                            console.error('動画保存エラー:', e);
                            setErrorMessage('動画の保存に失敗しました');
                            setIsProcessing(false);
                        }
                    };

                    // モバイル判定（ユーザーエージェントベース）
                    const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                    
                    // 動画の再生開始（モバイルでも試行）
                    let videoPlaySuccess = false;
                    try {
                        // ミュート状態で再生を試行（モバイルでもミュートなら再生できる場合がある）
                        videoElement.muted = true;
                        videoElement.currentTime = 0;
                        
                        // プロミス化してタイムアウト付きで再生試行
                        const playPromise = videoElement.play();
                        if (playPromise !== undefined) {
                            await Promise.race([
                                playPromise,
                                new Promise((_, reject) => setTimeout(() => reject(new Error('タイムアウト')), 3000))
                            ]);
                        }
                        videoPlaySuccess = true;
                        console.log('動画再生開始成功:', isMobileDevice ? 'モバイル' : 'PC');
                    } catch (playError) {
                        console.log('動画自動再生に失敗:', playError);
                        console.log('フレーム描画は手動で行います');
                        // 自動再生に失敗した場合でも録画は開始
                        videoPlaySuccess = false;
                    }

                    // 少し待ってから録画開始（Canvasが安定するまで）
                    await new Promise(resolve => setTimeout(resolve, 500));

                    // 録画開始
                    mediaRecorder.start(100);
                    console.log('録画開始 - 解像度:', canvas.width, 'x', canvas.height);

                    // フレーム描画のループ（モバイル対応版）
                    let frameCount = 0;
                    const totalFrames = 900; // 30秒 × 30fps
                    const videoDurationMs = Math.min(videoElement.duration * 1000 || 30000, 30000);
                    
                    const animate = () => {
                        // 動画再生が成功している場合は自動で進む
                        if (!videoPlaySuccess) {
                            // 動画再生が失敗している場合は手動でシークする
                            const progress = frameCount / totalFrames;
                            const targetTime = (videoDurationMs / 1000) * progress;
                            
                            // 動画の時間を手動で設定
                            if (videoElement.duration && targetTime <= videoElement.duration) {
                                videoElement.currentTime = targetTime;
                            }
                        }
                        
                        drawFrame();
                        frameCount++;
                        
                        // 最大フレーム数まで続行
                        if (frameCount < totalFrames) {
                            requestAnimationFrame(animate);
                        }
                    };
                    animate();

                    // 動画の長さまたは最大30秒で録画停止
                    const maxDuration = Math.min(videoElement.duration * 1000 || 30000, 30000);
                    console.log('録画時間設定:', maxDuration + 'ms');
                    
                    setTimeout(() => {
                        console.log('録画停止 - 総フレーム数:', frameCount);
                        mediaRecorder.stop();
                        videoElement.pause();
                        
                        // 音声用の動画要素も停止・クリーンアップ
                        if (tempVideo) {
                            tempVideo.pause();
                            URL.revokeObjectURL(tempVideo.src);
                            if (tempVideo.parentNode) {
                                tempVideo.parentNode.removeChild(tempVideo);
                            }
                            console.log('音声用動画要素をクリーンアップ');
                        }
                    }, maxDuration);

                } catch (error) {
                    console.error('動画生成エラー:', error);
                    setErrorMessage('動画の生成に失敗しました: ' + error.message);
                    setIsProcessing(false);
                    
                    // エラー時のクリーンアップ
                    if (tempVideo) {
                        tempVideo.pause();
                        URL.revokeObjectURL(tempVideo.src);
                    }
                }
            };

            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900">
                    {/* ヒーローセクション */}
                    <div className="relative overflow-hidden">
                        <div className="absolute inset-0 bg-gradient-to-r from-purple-500/20 to-pink-500/20"></div>
                        <div className="relative container mx-auto px-6 py-20">
                            <div className="text-center">
                                <div className="flex justify-center items-center mb-6">
                                    <h1 className="text-5xl font-bold bg-gradient-to-r from-purple-400 to-pink-400 bg-clip-text text-transparent">
                                        DreamCore Video Maker
                                    </h1>
                                </div>
                                <p className="hidden md:block text-xl text-gray-300 mb-8 max-w-2xl mx-auto">
                                    DreamCoreで作ったゲームの紹介動画を簡単生成！
                                </p>
                                
                                {/* ステップインジケーター */}
                                <div className="flex justify-center items-center mb-12 px-2 md:px-0">
                                    {steps.map((step, index) => {
                                        const Icon = step.icon;
                                        const isActive = index === currentStep;
                                        const isCompleted = index < currentStep;
                                        
                                        return (
                                            <div key={index} className="flex flex-col md:flex-row items-center flex-1 md:flex-none">
                                                <div className={`
                                                    flex items-center justify-center w-8 h-8 md:w-12 md:h-12 rounded-full border-2 transition-all duration-300
                                                    ${isActive ? 'border-purple-400 bg-purple-400 text-white' : 
                                                      isCompleted ? 'border-green-400 bg-green-400 text-white' : 'border-gray-600 text-gray-400'}
                                                `}>
                                                    <Icon />
                                                </div>
                                                                                <span className={`mt-1 md:mt-0 md:ml-2 md:mr-3 text-center text-xs md:text-base ${isActive ? 'text-purple-400' : 'text-gray-400'}`}>
                                    {step.title}
                                </span>
                                {index < steps.length - 1 && (
                                    <div className={`hidden md:block w-8 h-0.5 mr-3 ${isCompleted ? 'bg-green-400' : 'bg-gray-600'}`}></div>
                                )}
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        </div>
                    </div>
                    


                    {/* メインコンテンツ */}
                    <div className="container mx-auto px-6 pb-20">
                        <div className="max-w-4xl mx-auto">
                            
                            {/* ステップ0: ゲーム情報入力 */}
                            {currentStep === 0 && (
                                <div className="bg-slate-800/50 backdrop-blur-sm rounded-2xl p-8 border border-slate-700">
                                    <h2 className="text-2xl font-bold text-white mb-6 flex items-center">
                                        <Type />
                                        <span className="ml-3">ゲーム情報を入力</span>
                                    </h2>
                                    
                                    <div className="space-y-6">
                                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                            <div>
                                                <label className="block text-gray-300 mb-2">ゲームタイトル</label>
                                                <input
                                                    type="text"
                                                    value={manualData.title}
                                                    onChange={(e) => setManualData(prev => ({...prev, title: e.target.value}))}
                                                    className="w-full p-3 bg-slate-700 text-white rounded-lg border border-slate-600 focus:border-purple-400 focus:outline-none"
                                                    placeholder="ゲームタイトルを入力"
                                                />
                                            </div>
                                            <div>
                                                <label className="block text-gray-300 mb-2">説明文</label>
                                                <input
                                                    type="text"
                                                    value={manualData.description}
                                                    onChange={(e) => setManualData(prev => ({...prev, description: e.target.value}))}
                                                    className="w-full p-3 bg-slate-700 text-white rounded-lg border border-slate-600 focus:border-purple-400 focus:outline-none"
                                                    placeholder="ゲームの説明"
                                                />
                                            </div>
                                        </div>
                                        
                                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                            <div>
                                                <label className="block text-gray-300 mb-2">カバー画像</label>
                                                <input
                                                    ref={coverImageRef}
                                                    type="file"
                                                    accept="image/png,image/jpeg,image/jpg,image/gif"
                                                    onChange={(e) => handleImageUpload(e, 'coverImage')}
                                                    className="w-full p-3 bg-slate-700 text-white rounded-lg border border-slate-600"
                                                />
                                                <p className="text-xs text-gray-400 mt-1">PNG, JPEG, GIF対応</p>
                                            </div>
                                            <div>
                                                <label className="block text-gray-300 mb-2">アカウント画像</label>
                                                <input
                                                    ref={accountImageRef}
                                                    type="file"
                                                    accept="image/png,image/jpeg,image/jpg,image/gif"
                                                    onChange={(e) => handleImageUpload(e, 'accountImage')}
                                                    className="w-full p-3 bg-slate-700 text-white rounded-lg border border-slate-600"
                                                />
                                                <p className="text-xs text-gray-400 mt-1">PNG, JPEG, GIF対応</p>
                                            </div>
                                        </div>
                                        
                                        <div className="text-center">
                                            <button
                                                onClick={handleManualDataSubmit}
                                                className="bg-gradient-to-r from-purple-500 to-pink-500 text-white px-8 py-3 rounded-lg font-semibold hover:from-purple-600 hover:to-pink-600 transition-all"
                                            >
                                                次へ進む
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            )}

                            {/* ステップ1: 動画アップロード */}
                            {currentStep === 1 && (
                                <div className="bg-slate-800/50 backdrop-blur-sm rounded-2xl p-8 border border-slate-700">
                                    <h2 className="text-2xl font-bold text-white mb-6 flex items-center">
                                        <Video />
                                        <span className="ml-3">ゲーム動画をアップロード</span>
                                    </h2>
                                    
                                    <div className="border-2 border-dashed border-slate-600 rounded-xl p-12 text-center hover:border-purple-400 transition-all cursor-pointer"
                                         onClick={() => fileInputRef.current?.click()}>
                                        <Upload />
                                        <p className="text-xl text-gray-300 mb-2 mt-4">
                                            {videoFile ? videoFile.name : 'クリックして動画を追加'}
                                        </p>
                                        <p className="text-gray-500">MP4, WebM, MOV対応（最大100MB）</p>
                                        <p className="text-gray-500">最長で動画開始から30秒分使用します</p>
                                    </div>
                                    
                                    <input
                                        ref={fileInputRef}
                                        type="file"
                                        accept="video/*"
                                        onChange={handleVideoUpload}
                                        className="hidden"
                                    />
                                    
                                    {videoFile && (
                                        <div className="mt-6 text-center">
                                            <button
                                                onClick={() => setCurrentStep(2)}
                                                className="bg-gradient-to-r from-purple-500 to-pink-500 text-white px-8 py-3 rounded-lg font-semibold hover:from-purple-600 hover:to-pink-600 transition-all"
                                            >
                                                プレビューを確認
                                            </button>
                                        </div>
                                    )}
                                </div>
                            )}

                                        {/* ステップ2: プレビュー */}
            {currentStep === 2 && gameData && (
                <div className="bg-slate-800/50 backdrop-blur-sm rounded-2xl p-8 border border-slate-700">
                    <h2 className="text-2xl font-bold text-white mb-6 flex items-center">
                        <Play />
                        <span className="ml-3">プレビュー確認</span>
                    </h2>
                    
                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                        {/* 左側: 背景選択とプレビュー */}
                        <div className="space-y-6">
                            {/* 背景選択 */}
                            <div>
                                <h3 className="text-lg font-semibold text-white mb-4">背景を選択</h3>
                                <div className="grid grid-cols-3 gap-3">
                                    {[1, 2, 3, 4, 5, 6].map((bgIndex) => (
                                        <button
                                            key={bgIndex}
                                            onClick={() => setSelectedBackground(bgIndex)}
                                            className={`
                                                relative w-full aspect-square rounded-lg border-2 overflow-hidden transition-all hover:scale-105
                                                ${selectedBackground === bgIndex ? 'border-purple-400' : 'border-slate-600'}
                                            `}
                                        >
                                            <img
                                                src={`./assets/bg_thumbnail_${bgIndex}.png`}
                                                alt={`背景 ${bgIndex}`}
                                                className="w-full h-full object-cover"
                                                onError={(e) => {
                                                    // サムネイルが見つからない場合のフォールバック
                                                    e.target.style.display = 'none';
                                                    e.target.parentElement.style.backgroundColor = '#FF6B35';
                                                    e.target.parentElement.innerHTML = `<div class="flex items-center justify-center h-full text-white font-bold">${bgIndex}</div>`;
                                                }}
                                            />
                                            {selectedBackground === bgIndex && (
                                                <div className="absolute inset-0 bg-purple-400/20 flex items-center justify-center">
                                                    <div className="w-6 h-6 bg-purple-400 rounded-full flex items-center justify-center">
                                                        <svg className="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                                                        </svg>
                                                    </div>
                                                </div>
                                            )}
                                        </button>
                                    ))}
                                </div>
                            </div>

                            {/* 色相調整 */}
                            <div>
                                <h3 className="text-lg font-semibold text-white mb-4">色相調整</h3>
                                <div className="space-y-3">
                                    <div className="flex items-center justify-between">
                                        <span className="text-gray-300">色相:</span>
                                        <span className="text-white font-mono">{hueAdjustment}°</span>
                                    </div>
                                    <HueSlider 
                                        value={hueAdjustment} 
                                        onChange={setHueAdjustment}
                                    />
                                    <button
                                        onClick={() => setHueAdjustment(0)}
                                        className="text-purple-400 hover:text-purple-300 transition-all text-sm"
                                    >
                                        リセット
                                    </button>
                                </div>
                            </div>

                            {/* プレビュー表示 */}
                            <div>
                                <h3 className="text-lg font-semibold text-white mb-4">プレビュー</h3>
                                <div className="bg-slate-700/50 rounded-lg p-4">
                                    {isLoadingPreview ? (
                                        <div className="w-full max-w-sm mx-auto aspect-square bg-slate-600 rounded-lg flex flex-col items-center justify-center">
                                            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-purple-400 mb-3"></div>
                                            <span className="text-gray-400 text-sm">背景画像を読み込み中...</span>
                                        </div>
                                    ) : previewUrl ? (
                                        <img 
                                            src={previewUrl} 
                                            alt="プレビュー"
                                            className="w-full max-w-sm mx-auto rounded-lg"
                                        />
                                    ) : (
                                        <div className="w-full max-w-sm mx-auto aspect-square bg-slate-600 rounded-lg flex items-center justify-center">
                                            <span className="text-gray-400">プレビュー生成中...</span>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>

                        {/* 右側: ゲーム情報確認 */}
                        <div className="space-y-6">
                            {/* ゲーム情報編集セクション（モバイルではアコーディオン） */}
                            <div>
                                {isMobile ? (
                                    // モバイル: アコーディオンとして表示
                                    <div className="bg-slate-700/30 rounded-lg">
                                        <button
                                            onClick={() => setIsEditAccordionOpen(!isEditAccordionOpen)}
                                            className="w-full p-4 text-left flex items-center justify-between focus:outline-none focus:ring-2 focus:ring-purple-400 rounded-lg"
                                        >
                                            <h3 className="text-lg font-semibold text-white">ゲーム情報を編集</h3>
                                            <svg 
                                                className={`w-5 h-5 text-gray-400 transition-transform duration-200 ${isEditAccordionOpen ? 'rotate-180' : ''}`}
                                                fill="none" 
                                                stroke="currentColor" 
                                                viewBox="0 0 24 24"
                                            >
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                                            </svg>
                                        </button>
                                        <div className={`overflow-hidden transition-all duration-300 ease-in-out ${isEditAccordionOpen ? 'max-h-screen opacity-100' : 'max-h-0 opacity-0'}`}>
                                            <div className="px-4 pb-4 space-y-4">
                                                {/* タイトル編集 */}
                                                <div>
                                                    <label className="block text-gray-300 mb-2 text-sm">ゲームタイトル</label>
                                                    <input
                                                        type="text"
                                                        value={gameData.title}
                                                        onChange={(e) => {
                                                            const newData = {...gameData, title: e.target.value};
                                                            setGameData(newData);
                                                            // プレビューを即座に更新（新しいデータを直接渡す）
                                                            setTimeout(() => generatePreview(selectedBackground, hueAdjustment, newData), 100);
                                                        }}
                                                        className="w-full p-3 bg-slate-700 text-white rounded-lg border border-slate-600 focus:border-purple-400 focus:outline-none"
                                                        placeholder="ゲームタイトルを入力"
                                                    />
                                                </div>
                                                
                                                {/* 説明文編集 */}
                                                <div>
                                                    <label className="block text-gray-300 mb-2 text-sm">説明文</label>
                                                    <textarea
                                                        value={gameData.description}
                                                        onChange={(e) => {
                                                            const newData = {...gameData, description: e.target.value};
                                                            setGameData(newData);
                                                            // プレビューを即座に更新（新しいデータを直接渡す）
                                                            setTimeout(() => generatePreview(selectedBackground, hueAdjustment, newData), 100);
                                                        }}
                                                        className="w-full p-3 bg-slate-700 text-white rounded-lg border border-slate-600 focus:border-purple-400 focus:outline-none h-20 resize-none"
                                                        placeholder="ゲームの説明"
                                                    />
                                                </div>
                                                
                                                {/* カバー画像編集 */}
                                                <div>
                                                    <label className="block text-gray-300 mb-2 text-sm">カバー画像</label>
                                                    <div className="space-y-2">
                                                        {gameData.coverImage && (
                                                            <div className="bg-slate-700/50 rounded-lg p-3 mb-2">
                                                                <div className="flex items-center text-green-400 text-sm">
                                                                    <Image />
                                                                    <span className="ml-2 text-white">現在設定中: </span>
                                                                    <span className="ml-1 text-gray-300 break-all">
                                                                        {gameData.coverImage instanceof File ? gameData.coverImage.name : 'アップロード済み'}
                                                                    </span>
                                                                </div>
                                                            </div>
                                                        )}
                                                        <input
                                                            type="file"
                                                            accept="image/png,image/jpeg,image/jpg,image/gif"
                                                            onChange={(e) => {
                                                                const file = e.target.files[0];
                                                                if (file) {
                                                                    const supportedTypes = ['image/png', 'image/jpeg', 'image/jpg', 'image/gif'];
                                                                    if (!supportedTypes.includes(file.type)) {
                                                                        alert('PNG, JPEG, GIF形式の画像をアップロードしてください。');
                                                                        e.target.value = '';
                                                                        return;
                                                                    }
                                                                    const newData = {...gameData, coverImage: file};
                                                                    setGameData(newData);
                                                                    // プレビューを即座に更新（新しいデータを直接渡す）
                                                                    setTimeout(() => generatePreview(selectedBackground, hueAdjustment, newData), 100);
                                                                }
                                                            }}
                                                            className="w-full p-2 bg-slate-700 text-white rounded-lg border border-slate-600 text-sm"
                                                        />
                                                    </div>
                                                </div>
                                                
                                                {/* アカウント画像編集 */}
                                                <div>
                                                    <label className="block text-gray-300 mb-2 text-sm">アカウント画像</label>
                                                    <div className="space-y-2">
                                                        {gameData.accountImage && (
                                                            <div className="bg-slate-700/50 rounded-lg p-3 mb-2">
                                                                <div className="flex items-center text-green-400 text-sm">
                                                                    <User />
                                                                    <span className="ml-2 text-white">現在設定中: </span>
                                                                    <span className="ml-1 text-gray-300 break-all">
                                                                        {gameData.accountImage instanceof File ? gameData.accountImage.name : 'アップロード済み'}
                                                                    </span>
                                                                </div>
                                                            </div>
                                                        )}
                                                        <input
                                                            type="file"
                                                            accept="image/png,image/jpeg,image/jpg,image/gif"
                                                            onChange={(e) => {
                                                                const file = e.target.files[0];
                                                                if (file) {
                                                                    const supportedTypes = ['image/png', 'image/jpeg', 'image/jpg', 'image/gif'];
                                                                    if (!supportedTypes.includes(file.type)) {
                                                                        alert('PNG, JPEG, GIF形式の画像をアップロードしてください。');
                                                                        e.target.value = '';
                                                                        return;
                                                                    }
                                                                    const newData = {...gameData, accountImage: file};
                                                                    setGameData(newData);
                                                                    // プレビューを即座に更新（新しいデータを直接渡す）
                                                                    setTimeout(() => generatePreview(selectedBackground, hueAdjustment, newData), 100);
                                                                }
                                                            }}
                                                            className="w-full p-2 bg-slate-700 text-white rounded-lg border border-slate-600 text-sm"
                                                        />
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                ) : (
                                    // デスクトップ: 従来通り表示
                                    <div>
                                        <h3 className="text-lg font-semibold text-white mb-4">ゲーム情報を編集</h3>
                                        <div className="space-y-4">
                                            {/* タイトル編集 */}
                                            <div>
                                                <label className="block text-gray-300 mb-2 text-sm">ゲームタイトル</label>
                                                <input
                                                    type="text"
                                                    value={gameData.title}
                                                    onChange={(e) => {
                                                        const newData = {...gameData, title: e.target.value};
                                                        setGameData(newData);
                                                        // プレビューを即座に更新（新しいデータを直接渡す）
                                                        setTimeout(() => generatePreview(selectedBackground, hueAdjustment, newData), 100);
                                                    }}
                                                    className="w-full p-3 bg-slate-700 text-white rounded-lg border border-slate-600 focus:border-purple-400 focus:outline-none"
                                                    placeholder="ゲームタイトルを入力"
                                                />
                                            </div>
                                            
                                            {/* 説明文編集 */}
                                            <div>
                                                <label className="block text-gray-300 mb-2 text-sm">説明文</label>
                                                <textarea
                                                    value={gameData.description}
                                                    onChange={(e) => {
                                                        const newData = {...gameData, description: e.target.value};
                                                        setGameData(newData);
                                                        // プレビューを即座に更新（新しいデータを直接渡す）
                                                        setTimeout(() => generatePreview(selectedBackground, hueAdjustment, newData), 100);
                                                    }}
                                                    className="w-full p-3 bg-slate-700 text-white rounded-lg border border-slate-600 focus:border-purple-400 focus:outline-none h-20 resize-none"
                                                    placeholder="ゲームの説明"
                                                />
                                            </div>
                                            
                                            {/* カバー画像編集 */}
                                            <div>
                                                <label className="block text-gray-300 mb-2 text-sm">カバー画像</label>
                                                <div className="space-y-2">
                                                    {gameData.coverImage && (
                                                        <div className="bg-slate-700/50 rounded-lg p-3 mb-2">
                                                            <div className="flex items-center text-green-400 text-sm">
                                                                <Image />
                                                                <span className="ml-2 text-white">現在設定中: </span>
                                                                <span className="ml-1 text-gray-300 break-all">
                                                                    {gameData.coverImage instanceof File ? gameData.coverImage.name : 'アップロード済み'}
                                                                </span>
                                                            </div>
                                                        </div>
                                                    )}
                                                    <input
                                                        type="file"
                                                        accept="image/png,image/jpeg,image/jpg,image/gif"
                                                        onChange={(e) => {
                                                            const file = e.target.files[0];
                                                            if (file) {
                                                                const supportedTypes = ['image/png', 'image/jpeg', 'image/jpg', 'image/gif'];
                                                                if (!supportedTypes.includes(file.type)) {
                                                                    alert('PNG, JPEG, GIF形式の画像をアップロードしてください。');
                                                                    e.target.value = '';
                                                                    return;
                                                                }
                                                                const newData = {...gameData, coverImage: file};
                                                                setGameData(newData);
                                                                // プレビューを即座に更新（新しいデータを直接渡す）
                                                                setTimeout(() => generatePreview(selectedBackground, hueAdjustment, newData), 100);
                                                            }
                                                        }}
                                                        className="w-full p-2 bg-slate-700 text-white rounded-lg border border-slate-600 text-sm"
                                                    />
                                                </div>
                                            </div>
                                            
                                            {/* アカウント画像編集 */}
                                            <div>
                                                <label className="block text-gray-300 mb-2 text-sm">アカウント画像</label>
                                                <div className="space-y-2">
                                                    {gameData.accountImage && (
                                                        <div className="bg-slate-700/50 rounded-lg p-3 mb-2">
                                                            <div className="flex items-center text-green-400 text-sm">
                                                                <User />
                                                                <span className="ml-2 text-white">現在設定中: </span>
                                                                <span className="ml-1 text-gray-300 break-all">
                                                                    {gameData.accountImage instanceof File ? gameData.accountImage.name : 'アップロード済み'}
                                                                </span>
                                                            </div>
                                                        </div>
                                                    )}
                                                    <input
                                                        type="file"
                                                        accept="image/png,image/jpeg,image/jpg,image/gif"
                                                        onChange={(e) => {
                                                            const file = e.target.files[0];
                                                            if (file) {
                                                                const supportedTypes = ['image/png', 'image/jpeg', 'image/jpg', 'image/gif'];
                                                                if (!supportedTypes.includes(file.type)) {
                                                                    alert('PNG, JPEG, GIF形式の画像をアップロードしてください。');
                                                                    e.target.value = '';
                                                                    return;
                                                                }
                                                                const newData = {...gameData, accountImage: file};
                                                                setGameData(newData);
                                                                // プレビューを即座に更新（新しいデータを直接渡す）
                                                                setTimeout(() => generatePreview(selectedBackground, hueAdjustment, newData), 100);
                                                            }
                                                        }}
                                                        className="w-full p-2 bg-slate-700 text-white rounded-lg border border-slate-600 text-sm"
                                                    />
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                )}
                            </div>
                            
                            <div>
                                <h3 className="text-lg font-semibold text-white mb-4">動画ファイル</h3>
                                <div className="bg-slate-700/50 rounded-lg p-4">
                                    <div className="flex items-center">
                                        <Video />
                                        <span className="text-gray-300 ml-2">ファイル名: </span>
                                        <span className="text-white font-medium text-sm break-all">{videoFile?.name}</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div className="mt-8 text-center">
                        <button
                            onClick={generateVideo}
                            className="bg-gradient-to-r from-green-500 to-emerald-500 text-white px-8 py-4 rounded-lg font-semibold text-lg hover:from-green-600 hover:to-emerald-600 transition-all flex items-center mx-auto"
                        >
                            <Sparkles />
                            <span className="ml-2">動画を生成する</span>
                        </button>
                    </div>
                </div>
            )}

                            {/* ステップ3: 生成中・完了 */}
                            {currentStep === 3 && (
                                <div className="bg-slate-800/50 backdrop-blur-sm rounded-2xl p-8 border border-slate-700">
                                    {isProcessing ? (
                                        <div className="text-center px-4 md:px-0">
                                            <h2 className="text-xl md:text-2xl font-bold text-white mb-6">動画を生成中...</h2>
                                            <div className="w-full bg-slate-700 rounded-full h-4 mb-4">
                                                <div 
                                                    className="bg-gradient-to-r from-purple-500 to-pink-500 h-4 rounded-full transition-all duration-300"
                                                    style={{ width: `${progress}%` }}
                                                ></div>
                                            </div>
                                            <p className="text-gray-300">{progress}% 完了</p>
                                        </div>
                                    ) : errorMessage ? (
                                        <div className="text-center px-4 md:px-0">
                                            <h2 className="text-xl md:text-2xl font-bold text-red-400 mb-6">エラーが発生しました</h2>
                                            <p className="text-gray-300 mb-6">{errorMessage}</p>
                                            <button
                                                onClick={() => {
                                                    setCurrentStep(2);
                                                    setErrorMessage('');
                                                }}
                                                className="bg-gradient-to-r from-purple-500 to-pink-500 text-white px-6 md:px-8 py-3 rounded-lg font-semibold hover:from-purple-600 hover:to-pink-600 transition-all w-full md:w-auto"
                                            >
                                                再試行
                                            </button>
                                        </div>
                                    ) : outputVideo ? (
                                        <div className="text-center px-4 md:px-0">
                                            <h2 className="text-xl md:text-2xl font-bold text-white mb-6 flex flex-col md:flex-row items-center justify-center">
                                                <Sparkles />
                                                <span className="mt-2 md:mt-0 md:ml-3">動画生成完了！</span>
                                            </h2>
                                            <div className="mb-6">
                                                <video
                                                    controls
                                                    className="mx-auto rounded-lg w-full max-w-md"
                                                    src={outputVideo}
                                                />
                                            </div>
                                            <div className="flex flex-col md:flex-row gap-4 justify-center items-center">
                                                <a
                                                    href={outputVideo}
                                                    download={`dreamcore-video.${outputVideoMimeType?.includes('mp4') ? 'mp4' : 'webm'}`}
                                                    className="bg-gradient-to-r from-green-500 to-emerald-500 text-white px-6 md:px-8 py-3 md:py-4 rounded-lg font-semibold text-base md:text-lg hover:from-green-600 hover:to-emerald-600 transition-all inline-flex items-center w-full md:w-auto justify-center"
                                                >
                                                    <Download />
                                                    <span className="ml-2">動画をダウンロード</span>
                                                </a>
                                                
                                                <a
                                                    href="https://x.com/suemaruuuuuuX"
                                                    target="_blank"
                                                    rel="noopener noreferrer"
                                                    className="bg-black text-white border border-gray-700 px-6 md:px-8 py-3 md:py-4 rounded-lg font-semibold text-base md:text-lg hover:bg-gray-900 transition-all inline-flex items-center w-full md:w-auto justify-center"
                                                >
                                                    <XIcon />
                                                    <span className="ml-2">作者をフォロー</span>
                                                </a>
                                            </div>
                                            <div className="mt-6">
                                                <button
                                                    onClick={() => {
                                                        setCurrentStep(0);
                                                        setGameData(null);
                                                        setVideoFile(null);
                                                        setOutputVideo(null);
                                                        setOutputVideoMimeType(null);
                                                        setErrorMessage('');
                                                        setManualData({ title: '', description: '', coverImage: null, accountImage: null });
                                                        setSelectedBackground(1);
                                                        setHueAdjustment(0);
                                                        setPreviewUrl(null);
                                                        setBackgroundImages({}); // キャッシュもクリア
                                                        setIsLoadingPreview(false);
                                                    }}
                                                    className="text-purple-400 hover:text-purple-300 transition-all text-base md:text-lg"
                                                >
                                                    新しい動画を作成
                                                </button>
                                            </div>
                                        </div>
                                    ) : null}
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Hidden Canvas for video generation */}
                    <canvas 
                        ref={canvasRef} 
                        className="hidden"
                        width="1000"
                        height="1000"
                        style={{ width: '1000px', height: '1000px' }}
                    />
                    
                    {/* Hidden Canvas for preview generation */}
                    <canvas 
                        ref={previewCanvasRef} 
                        className="hidden"
                        width="400"
                        height="400"
                        style={{ width: '400px', height: '400px' }}
                    />
                    
                    {/* フッター */}
                    <footer className="mt-12 py-6 border-t border-slate-700 bg-slate-800/30">
                        <div className="container mx-auto px-6 text-center">
                            <p className="text-gray-400 text-sm">
                                DreamCore Video Maker ver1.1.4 Developed by{' '}
                                <a 
                                    href="https://x.com/suemaruuuuuuX" 
                                    target="_blank" 
                                    rel="noopener noreferrer"
                                    className="text-blue-400 hover:text-blue-300 transition-all font-medium"
                                >
                                    @suemaruuuuuuX
                                </a>
                            </p>
                        </div>
                    </footer>
                </div>
            );
        };

        ReactDOM.render(<DreamCoreVideoGenerator />, document.getElementById('root'));
    </script>
</body>
</html>